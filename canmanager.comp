component canmanager;

// DS302 boot completed
pin out bit boot_complete   """DS302 boot completed""";


// we are creating the pins / params manually. The above is just so that comp will shut up about "you must have at least one pin"
// might be easier to convert to straight C and be done with it

option extra_setup;
option extra_cleanup;
//option constructable no;
// we can only have ONE instance of this.
option singleton yes;

function update fp;

license "GPLv3";
author "Gabriel Curteanu"; 
;;

#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <canfestival.h>
#include "EPOScontrol.h"
#include "epos.h"
#include "ds302.h"
#include "eposconfig.h"

int slaveid[EPOS_MAX_DRIVES] = { 0, 0, 0, 0, 0 };
RTAPI_MP_ARRAY_INT(slaveid,EPOS_MAX_DRIVES,"CAN slave IDs controlled by this master");
int heartbeat[EPOS_MAX_DRIVES] = { 0, 0, 0, 0, 0 };
RTAPI_MP_ARRAY_INT(heartbeat,EPOS_MAX_DRIVES,"The heartbeat values for each slave ID");
int master_can_id = 0x7F;
RTAPI_MP_INT(master_can_id,"The master's CAN ID");
char *dcf = NULL;
RTAPI_MP_STRING(dcf, "The DCF initialisation data");

typedef struct {
    // params
    hal_u32_t   slavecount;                             // slave count, out
    hal_u32_t   slave_id[EPOS_MAX_DRIVES];              // slave ID, out
    hal_float_t position_scale[EPOS_MAX_DRIVES];        // position scale, in
    // pins
    hal_bit_t   *enable[EPOS_MAX_DRIVES];               // enable, input
    hal_bit_t   *faulted[EPOS_MAX_DRIVES];              // fault, out
    hal_float_t *position_command[EPOS_MAX_DRIVES];     // position command, input
    hal_float_t *velocity_command[EPOS_MAX_DRIVES];     // velocity command, input
    hal_float_t *position_feedback[EPOS_MAX_DRIVES];    // position feedback, output
    hal_float_t *velocity_feedback[EPOS_MAX_DRIVES];    // velocity feedback, output
    hal_s32_t   *position_counts[EPOS_MAX_DRIVES];      // position counts, output
    
    // internal data
    hal_bit_t   prev_enabled[EPOS_MAX_DRIVES];          // previous enabled state for edge detect
} canmanager_t;

static canmanager_t *canmanager;

//Global variables
CO_Data EPOScontrol_Data;

//RTDM library handle
void *rtdm_lib_handle;
void *pthread_lib_handle;

//Variables for the setup or in terms of CANOpen Initialisation of the master.

char* LibraryPath="/usr/local/lib/libcanfestival_can_socket.so";
s_BOARD MasterBoard = {"0", "1M"};

/* callbacks kept mostly for debugging */
/* Beware, DS302 overrides some of them */

void CanManager_heartbeatError(CO_Data* d, UNS8 heartbeatID)
{
    rtapi_print("CANmanager: CB heartbeatError %02x\n", heartbeatID);
}

void CanManager_initialisation(CO_Data* d)
{
    rtapi_print("CANmanager: CB initialization\n");
}

void CanManager_preOperational(CO_Data* d)
{
    rtapi_print("CANmanager: CB preOperational mode \n");
}

void CanManager_operational(CO_Data* d)
{
    rtapi_print("CANmanager: CB operational\n");
}

void CanManager_stopped(CO_Data* d)
{
    rtapi_print("CANmanager: CB stopped\n");
}

void CanManager_post_sync(CO_Data* d)
{
    rtapi_print("CANmanager: CB SYNC\n");
}

void CanManager_post_TPDO(CO_Data* d)
{
    rtapi_print("CANmanager: CB TPDO\n");    
}

void CanManager_post_SlaveBootup(CO_Data* d, UNS8 nodeid)
{
    rtapi_print("CANmanager: CB SlaveBootup %02x\n", nodeid);
}

void CanManager_post_SlaveStateChange(CO_Data* d, UNS8 nodeid,  e_nodeState newNodeState)
{
    rtapi_print("CANmanager: CB SlaveStateChange %02x -> %02x\n", nodeid, newNodeState);
}

/***************************  INIT  *****************************************/
void InitNodes(CO_Data* d, UNS32 id)
{
    setState(&EPOScontrol_Data, Initialisation);
}

/***************************  EXIT  *****************************************/
void Exit(CO_Data* d, UNS32 id)
{
    // is this needed? disable for now
    // masterSendNMTstateChange(&EPOScontrol_Data, master_can_id, NMT_Stop_Node);

    //Stop master
    setState(&EPOScontrol_Data, Stopped);
}

int     setup_pins (const char *prefix) {
    
    int     retcode;
    
    // the slave count is per instance
    retcode = hal_param_u32_newf (HAL_RO, &canmanager->slavecount, comp_id,
        "%s.slave-count", prefix);
    if (retcode != 0) { return retcode; }
    
    for (i = 0; i < canmanager->slavecount; i++) {

        // the state pins, enable and faulted
        retcode = hal_pin_bit_newf(HAL_IN, &canmanager->enable[i], comp_id,
        "%s.%d.enable", prefix, i);
        if (retcode != 0) { return retcode; }

        retcode = hal_pin_bit_newf(HAL_OUT, &canmanager->faulted[i], comp_id,
        "%s.%d.faulted", prefix, i);
        if (retcode != 0) { return retcode; }
        
        // raw encoder count
        retcode = hal_pin_s32_newf(HAL_OUT, &canmanager->position_counts[i], comp_id,
        "%s.%d.counts", prefix, i);
        if (retcode != 0) { return retcode; }

        // position command and feedback in units
        retcode = hal_pin_float_newf(HAL_IN, &canmanager->position_command[i], comp_id,
        "%s.%d.position-cmd", prefix, i);
        if (retcode != 0) { return retcode; }

        retcode = hal_pin_float_newf(HAL_OUT, &canmanager->position_feedback[i], comp_id,  
        "%s.%d.position-fb", prefix, i);
        if (retcode != 0) { return retcode; }

        // velocity command and feedback in units
        retcode = hal_pin_float_newf(HAL_IN, &canmanager->velocity_command[i], comp_id,
        "%s.%d.velocity-cmd", prefix, i);
        if (retcode != 0) { return retcode; }

        retcode = hal_pin_float_newf(HAL_OUT, &canmanager->velocity_feedback[i], comp_id,  
        "%s.%d.velocity-fb", prefix, i);
        if (retcode != 0) { return retcode; }

        // params
        retcode = hal_param_u32_newf (HAL_RO, &canmanager->slave_id[i], comp_id,
        "%s.%d.slave-id", prefix, i);
        if (retcode != 0) { return retcode; }

        retcode = hal_param_float_newf (HAL_RW, &canmanager->position_scale[i], comp_id,
        "%s.%d.position-scale", prefix, i);
        if (retcode != 0) { return retcode; }

        // setup default values
        canmanager->position_scale[i] = 1;
        canmanager->prev_enabled[i] = 0;
    }

    return 0;
}

EXTRA_SETUP()
{
    if (!dcf) {
        rtapi_print ("CANmanager: DCF file not provided, unable to load\n");
        return 1;
    }

    canmanager = hal_malloc(sizeof(canmanager_t));
    if (!canmanager)
        return 1;

    // load the params
    int i;
    for (i = 0; i < EPOS_MAX_DRIVES; i++)
        if (slaveid[i] != 0) {
            canmanager->slave_id[canmanager->slavecount++] = slaveid[i];
        }


    // comp_id = already set
    // prefix = the component prefix
    rtapi_print ("Component ID is %d\n", comp_id);

    // create the pins
    int retcode = setup_pins(prefix);
    if (retcode != 0)
        return retcode;

    rtapi_print ("CANmanager: Load libpthread_rt.so\n");
    pthread_lib_handle = dlopen ("libpthread_rt.so", RTLD_NOW | RTLD_GLOBAL);
    if (!pthread_lib_handle) {
        rtapi_print ("CANmanager: pthread_rt load failed\n");
        return 1;
    }

    rtapi_print ("CANmanager: Loading librtdm.so\n");
    rtdm_lib_handle = dlopen ("/usr/lib/librtdm.so", RTLD_NOW | RTLD_GLOBAL);
    if (!rtdm_lib_handle) {
        rtapi_print ("CANmanager: RTDM load failed\n");
        return 1;
    }

    rtapi_print ("CANmanager: Timers initialized\n");
    TimerInit();

    rtapi_print ("CANmanager: Loading the driver\n");
    LoadCanDriver(LibraryPath);
                
    if(!canOpen(&MasterBoard,&EPOScontrol_Data)){
        rtapi_print("CANmanager: Cannot open Master Board\n");
    }
    else{
        rtapi_print("CANmanager: Opened Master Board\n");
    }

    // Set the master ID
    setNodeId(&EPOScontrol_Data, master_can_id);

    // initialize the master
    epos_initialize_master (&EPOScontrol_Data, dcf);
    //display_dcf_set (&EPOS_drive.dcf_data);
    
    // add the defined slave nodeids
    for (i = 0; i < canmanager->slavecount; i++) {
        rtapi_print ("CANmanager: Adding slave id %02x\n", canmanager->slave_id[i]);
        epos_add_slave (canmanager->slave_id[i]);
    }

    // load the DCF configuration for the master node before starting the timers and such
    ds302_load_dcf_local (&EPOScontrol_Data);

    // set up callbacks
    EPOScontrol_Data.heartbeatError = CanManager_heartbeatError;
    EPOScontrol_Data.initialisation = CanManager_initialisation;
    EPOScontrol_Data.preOperational = CanManager_preOperational;
    EPOScontrol_Data.operational = CanManager_operational;
    EPOScontrol_Data.stopped = CanManager_stopped;
    EPOScontrol_Data.post_sync = CanManager_post_sync;
    EPOScontrol_Data.post_TPDO = CanManager_post_TPDO;
    EPOScontrol_Data.post_SlaveBootup = CanManager_post_SlaveBootup;
    EPOScontrol_Data.post_SlaveStateChange = CanManager_post_SlaveStateChange;
    
    // Start timer thread
    StartTimerLoop(&InitNodes);

    // Init DS302 process
    ds302_init (&EPOScontrol_Data);

    boot_complete = 0;
    // kickoff DS302 boot process
    EnterMutex();
    ds302_start (&EPOScontrol_Data);
    LeaveMutex();

    // add the defined slave node IDs to the heartbeat consumer
    for (i = 0; i < canmanager->slavecount; i++) {
        if (heartbeat[i] > 0) {
            rtapi_print ("CANmanager: Starting HB for slave id %02x with a %d ms\n", canmanager->slave_id[i], heartbeat[i]);
            ds302_setHeartbeat (&EPOScontrol_Data, canmanager->slave_id[i], heartbeat[i]);
        }
    }
        
    rtapi_print("CANmanager: finished initialization.\n");

    return 0;
}


EXTRA_CLEANUP()
{
    // disable the drive
    if (epos_drive_operational(0)) {
        EnterMutex();    
        epos_disable_drive (0);
        sendPDOevent(&EPOScontrol_Data);
        LeaveMutex();
    }
    
    // put the master into pre-op
    setState (&EPOScontrol_Data, Pre_operational);

    // stop the threads and stop the master
    StopTimerLoop(&Exit);

    canClose(&EPOScontrol_Data);
    
    TimerCleanup();

    if (rtdm_lib_handle)
        dlclose (rtdm_lib_handle);
    
    if (pthread_lib_handle)
        dlclose (pthread_lib_handle);


    rtapi_print ("CANmanager: stopped and unloaded\n");
}

FUNCTION(update) 
{
    int     i;
    //rtapi_print ("update called\n");

    // do drive startup after the manager completed boot
    // this should fire only once, as boot completes
    if (boot_complete == 0 && ds302_status(&EPOScontrol_Data) == BootCompleted) {
            // set the boot complete param
            boot_complete = 1;

            // this probably will have to rely on module params/config?
            rtapi_print ("CANmanager: Setting drive params\n");
            EnterMutex();
            
            for (i = 0; i < canmanager->slavecount; i++) {
                // set operation mode
                epos_set_mode (i, EPOS_MODE_PPM);
            
                // set motion type, segmented or continuous
                epos_set_continuous (i);
                //epos_set_segmented(0);
            
                // set values as absolute
                epos_set_absolute (i);
            
                // set execution for commands
                epos_execute (i);

                // enable the drive
                // epos_enable_drive (i);   // we now control the enable via the enable pin
            }

            // load values to the drive via PDO (note, above routines are LOCAL)
            sendPDOevent(&EPOScontrol_Data);
            LeaveMutex();
            
    } else if (ds302_status(&EPOScontrol_Data) != BootCompleted) {
        // boot is still in progress / not done
        // let's update the boot status for each system
    }

    /*
     * This is the main processing section
     * It does enable/fault
     * It processes the commands and provides the results
     *
     * NOTE: all WRITE calls to the CAN stack MUST use mutexes (EnterMutex/LeaveMutex)
     * NOTE: for READ calls to the CAN stack, we should be fine without mutexes (if calls short)
     *
     */
    
    // one optimization idea: after the loop is done, do a SINGLE call to sendPDO
    // this will reduce the amount of locking/unlocking
    
    for (i = 0; i < canmanager->slavecount ; i++) {

        // enable section.
        // the fault recovery is actually a SM (clearfault, wait to get to disabled, then enable)
        // if it doesn't get to disabled after fault recovery in a specific time (Nms) signal fault?
        // this needs more thinking
        if (*(canmanager->enable[i]) != canmanager->prev_enabled[i]) {
            // we have an edge in the enabled state
            if (*(canmanager->enable[i]) != 0) {
                // we should ENABLE the drive. Send the PDO ASAP
                //EnterMutex();
                epos_enable_drive (i);
                //sendPDOevent(&EPOScontrol_Data);
                //LeaveMutex();
            } else {
                // we should DISABLE the drive. Send the PDO ASAP
                //EnterMutex();
                epos_disable_drive (i);
                //sendPDOevent(&EPOScontrol_Data);
                //LeaveMutex();
            }
            // save the value
            canmanager->prev_enabled[i] = *(canmanager->enable[i]);
        }
        
        // position / speed handling
        if (epos_drive_operational(i)) {

            // calculate target position
            hal_s32_t   demandpos = (hal_s32_t)(*(canmanager->position_command[i]) * canmanager->position_scale[i]);
            // do motion (we can base comparison on the OD object directly)
            if (demandpos != PositionDemandValue[i]) {
                // new move required
                // rtapi_print ("CANmanager: Executing move to %ld from %ld [%d]\n", demandpos, PositionDemandValue[i], i);

                //EnterMutex();
                epos_do_move_PPM(i, demandpos);
                //LeaveMutex();
                // if the move succeeds, it will update the PositionDemandValue with the param value
                // this way, we'll re-execute the move automatically if for whatever reason was not executed
            }

            // load the feedback value
            *(canmanager->position_counts[i]) = PositionActualValue[i];

            // calculate position in units
            *(canmanager->position_feedback[i]) = *(canmanager->position_counts[i]) / canmanager->position_scale[i];
        }
    }
    
    // generate the PDOs. This is the ONLY lock needed
    EnterMutex();
    sendPDOevent(&EPOScontrol_Data);
    LeaveMutex();
}
