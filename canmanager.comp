component canmanager;

pin in s32 pin_position_cmd  """Position command""";
pin in s32 pin_velocity_cmd  """Velocity command""";
pin out s32 pin_position_fb  """Position feedback""";
pin out s32 pin_velocity_fb  """Velocity feedback""";

option extra_setup;
option extra_cleanup;
//option constructable no;
// we can only have ONE instance of this.
option singleton yes;

function update fp;

license "GPLv3";
author "Gabriel Curteanu"; 
;;

#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <canfestival.h>
#include "EPOScontrol.h"
#include "epos.h"
#include "ds302.h"

#define NMT_MASTER_NODE     0x7F

//Global variables
CO_Data EPOScontrol_Data;

//RTDM library handle
void *rtdm_lib_handle;
void *pthread_lib_handle;

//Variables for the setup or in terms of CANOpen Initialisation of the master.

char* LibraryPath="/usr/local/lib/libcanfestival_can_socket.so";
s_BOARD MasterBoard = {"0", "1M"};

void CanManager_heartbeatError(CO_Data* d, UNS8 heartbeatID)
{
    rtapi_print("CanManager_heartbeatError %d\n", heartbeatID);
}

void CanManager_initialisation(CO_Data* d)
{
    rtapi_print("CanManager initializing\n");
}

void CanManager_preOperational(CO_Data* d)
{
    rtapi_print("CanManager is in preOperational mode \n");
}

void CanManager_operational(CO_Data* d)
{
    rtapi_print("CanManager_operational\n");

    //This constants are used to start the SYNC signal from the Master LCNC.
    UNS32 SYNC_TIME = 0x07D0;   // 0x03E8 This value is for a 1000 uSeg SYNC cycle. TODO Garcia: this could be a parameter for this component
    UNS32 START_SYNC = 0x40000080;  // Reference for this value "CANOpen Memento of Francis Dupin, August 2009", SYNC configuration.

#ifdef __USE_SYNC__
    UNS32 size = sizeof(UNS32);
    if (sync_enabled) {
        //TODO Garcia: SYNC configurartion could be optional using an sync_enable param. But the transmision mode of the PDOs have to be set according to this.
        //This constant is used to start the SYNC signal from the Master LCNC.
        /*****************************************
         *       Set Master to trasmit SYNCs     *
         *****************************************/
        writeLocalDict( &EPOScontrol_Data, /*CO_Data* d*/
                0x1006, /*UNS16 index*/
                0x00, /*UNS8 subind*/ 
                &SYNC_TIME, /*void * pSourceData,*/ 
                &size, /* UNS8 * pExpectedSize*/
                RW);  /* UNS8 checkAccess */

        writeLocalDict( &EPOScontrol_Data, /*CO_Data* d*/
                0x1005, /*UNS16 index*/
                0x00, /*UNS8 subind*/ 
                &START_SYNC, /*void * pSourceData,*/ 
                &size, /* UNS8 * pExpectedSize*/
                RW);  /* UNS8 checkAccess */
    }
#endif
}

void CanManager_stopped(CO_Data* d)
{
    rtapi_print("CanManager_stopped\n");
}

void CanManager_post_sync(CO_Data* d)
{
//    rtapi_print(" 0x2000:%2.2d 0x2014:%2.2d 0x2015:%2.2d          \r",MasterMapInt32_1, MasterMapInt32_5, MasterMapInt32_6);
}

void CanManager_post_TPDO(CO_Data* d)
{
    rtapi_print("CanManager_post_TPDO\n");    
}

void CanManager_post_SlaveBootup(CO_Data* d, UNS8 nodeid)
{
    rtapi_print("TestMaster_post_SlaveBootup %x\n", nodeid);
}

void CanManager_post_SlaveStateChange(CO_Data* d, UNS8 nodeid,  e_nodeState newNodeState)
{
    rtapi_print("CanManager_post_SlaveStateChange %x -> %x\n", nodeid, newNodeState);
}

/***************************  INIT  *****************************************/
void InitNodes(CO_Data* d, UNS32 id)
{
    setState(&EPOScontrol_Data, Initialisation);
}

/***************************  EXIT  *****************************************/
void Exit(CO_Data* d, UNS32 id)
{
    // is this needed?
    masterSendNMTstateChange(&EPOScontrol_Data, NMT_MASTER_NODE, NMT_Stop_Node);

    //Stop master
    setState(&EPOScontrol_Data, Stopped);
}


EXTRA_SETUP()
{
    rtapi_print ("CANmanager: Load libpthread_rt.so\n");
    pthread_lib_handle = dlopen ("libpthread_rt.so", RTLD_NOW | RTLD_GLOBAL);
    if (!pthread_lib_handle) {
        rtapi_print ("CANmanager: pthread_rt load failed\n");
        return 1;
    }
    
    rtapi_print ("CANmanager: Loading librtdm.so\n");
    rtdm_lib_handle = dlopen ("/usr/lib/librtdm.so", RTLD_NOW | RTLD_GLOBAL);
    if (!rtdm_lib_handle) {
        rtapi_print ("CANmanager: RTDM load failed\n");
        return 1;
    }

    rtapi_print ("CANmanager: Timers initialized\n");
    TimerInit();

    rtapi_print ("CANmanager: Loading the driver\n");
    LoadCanDriver(LibraryPath);
                
    if(!canOpen(&MasterBoard,&EPOScontrol_Data)){
        rtapi_print("CANmanager: Cannot open Master Board\n");
    }
    else{
        rtapi_print("CANmanager: Opened Master Board\n");
    }

    // Set the master ID
    setNodeId(&EPOScontrol_Data, NMT_MASTER_NODE);

    // initialize the master
    epos_initialize_master (&EPOScontrol_Data, "dcfdata.txt");
    //display_dcf_set (&EPOS_drive.dcf_data);
    
    // add the defined slave nodeids
    epos_add_slave (0x01);

    // load the DCF configuration for the master node before starting the timers and such
    ds302_load_dcf_local (&EPOScontrol_Data);

    // set up callbacks
    EPOScontrol_Data.heartbeatError = CanManager_heartbeatError;
    EPOScontrol_Data.initialisation = CanManager_initialisation;
    EPOScontrol_Data.preOperational = CanManager_preOperational;
    EPOScontrol_Data.operational = CanManager_operational;
    EPOScontrol_Data.stopped = CanManager_stopped;
    EPOScontrol_Data.post_sync = CanManager_post_sync;
    EPOScontrol_Data.post_TPDO = CanManager_post_TPDO;
    EPOScontrol_Data.post_SlaveBootup = CanManager_post_SlaveBootup;
    EPOScontrol_Data.post_SlaveStateChange = CanManager_post_SlaveStateChange;
    
    // Start timer thread
    StartTimerLoop(&InitNodes);

    // Init DS302 process
    OperationMode[0] = 1;
    ds302_init (&EPOScontrol_Data);

    // kickoff DS302 boot process
    EnterMutex();
    ds302_start (&EPOScontrol_Data);
    LeaveMutex();

    rtapi_print("CANmanager: finished initialization.\n");

    return 0;
}


EXTRA_CLEANUP()
{
    // Reset the slave node for next use (will stop emitting heartbeat)
    StopTimerLoop(&Exit);

    canClose(&EPOScontrol_Data);
    
    TimerCleanup();

    if (rtdm_lib_handle)
        dlclose (rtdm_lib_handle);
    
    if (pthread_lib_handle)
        dlclose (pthread_lib_handle);

    rtapi_print ("CANmanager: stopped and unloaded\n");
}

int         boot_done = 0;
int         init_done = 0;
INTEGER32   current_position_command = 0;

FUNCTION(update) 
{
    //rtapi_print ("update called\n");

    // do drive startup after the manager completed boot
    if (boot_done == 0 && ds302_status(&EPOScontrol_Data) == BootCompleted) {
            boot_done = 1;

            rtapi_print ("CANmanager: Initialising drives\n");
            EnterMutex();

            epos_set_continuous (0);
            //epos_set_segmented(0);
            epos_set_absolute (0);
            epos_execute (0);

            VelocityDemandValue[0] = 1000;

            epos_enable_drive (0);
            epos_set_mode (0, EPOS_MODE_PPM);
            // load values to the drive
            sendPDOevent(&EPOScontrol_Data);

            LeaveMutex();
    }            

    // if we're operational, then do work
    if (epos_drive_operational(0)) {

        // do motion
        if (pin_position_cmd != current_position_command) {
            // new move required
            rtapi_print ("CANmanager: Executing move to %ld\n", pin_position_cmd);

            current_position_command = pin_position_cmd;
            epos_do_move_PPM(0, current_position_command);
        }

        // load the feedback value
        pin_position_fb = PositionActualValue[0];
    }
}
